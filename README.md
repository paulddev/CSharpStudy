# Learning C#

### 컴파일러와 인터프리터
`컴파일러`는 소스 코드를 컴파일하여 실행 파일로 만든다. 프로그램을 실행하기 위해서는 `실행 파일`만 있으면 되며, 소스 코드는 전혀 필요하지 않는다. 빌드하고 커피타임이 가능하다.

`인터프리터`는 소스 코드를 미리 실행 파일로 만드는 작업이 필요하지 않다. 소스 코드를 실시간으로 기계어로 해석하여 실행하기 때문이다. 즉각적인 피드백을 받을 수 있다.

컴파일 방식에서는 오류가 발견되어 이를 수정하고 확인하려면 무조건 컴파일 과정을 거쳐야 하지만, 인터프리터 방식은 오류를 발견했을 때 코드를 수정하면 바로 실행이 가능하므로 컴파일 방식에 비해서 개발 속도가 빠르다. 최근 인터프리터 방식의 프로그래밍 언어는 `PHP`, `Python`, `Ruby`, `Perl` 이 있다.

`컴파일(Compile)`은 어셈블리어(복잡한 기계어 명령을 사람이 이해할 수 있는 기호나 단어)를 일종의 번역 과정을 거쳐 컴퓨터가 이해하는 기계어 코드로 변환하는 것을 말한다.

### C#의 기본 파일과 환경 설정
`Hello.cs` -> 컴파일러 -> `Hello.exe`

컴파일러는 소스 파일을 입력받아서 실행 파일을 만든다.

C# 프로젝트 파일은 확장자가 `.csproj`

1. 솔루션
2. C# 프로젝트
3. C# 소스 코드

C# 프로그램의 각 요소는 코드가 실행되는 시점에 비로소 메모리에 할당되는 반면, `static`키워드로 수식되는 코드는 프로그램이 처음 구동될 때부터 이미 메모리에 할당된다는 특징이 있다.

### CLR (Common Language Runtime)
C#으로 만든 프로그램이 실행되는 환경을 말한다.

프로그램이 실행되면 `CLR`은 프로그램을 메모리에 올린 후 프로그램의 진입점을 찾는다. 이때 `Main()`메소드가 static으로 수식되어 있지 않다면 CLR은 진입점을 찾지 못한다.

    `C# 애플리케이션` | `VB.NET 애플리케이션` | `C++ 애플리케이션`
-------------------------------------------------------------
                      `.NET 라이브러리`
-------------------------------------------------------------
                            `CLR`
-------------------------------------------------------------
                        `OS 운영체제`
-------------------------------------------------------------
                          `하드웨어`

CLR은 자바의 실행 환경인 자바머신과 비슷한 역할을 한다.

`C# 컴파일러`는 C# 소스 코드를 컴파일해서 `IL(Intermediate Language)`라는 중간 언어로 작성된 실행 파일을 만들어 낸다. 사용자가 이 파일을 실행시키면 CLR이 중간 코드를 읽어 들여 다시 하드웨어가 이해할 수 있는 `네이티브 코드`로 컴파일한 후 실행시킨다. 이것을 `JIT(Just In TIme), 적시 컴파일` 이라고 한다.

`JIT`은 실행에 필요한 코드를 실행할 때마다 실시간으로 컴파일해서 실행한다는 뜻이다.

이 방식의 장점은 바로 플랫폼에 최적화된 코드를 만들어내지만, 실행 시 이루어지는 컴파일 비용이 부담이 된다.

CLR은 이것 말고도 다양한 것을 지원한다.
1. 프로그램의 오류가 발생했을 때 핸들링
2. 자동 메모리 관리 (`가비지 컬렉션, GC`), 프로그램에서 더 이상 사용하지 않는 메모리를 `쓰레기(Garbage)`로 간주하여 `수거(Collection)`한다.
3. 언어 간의 상속 지원
4. COM과의 상호 운영성 지원


### 오버플로우(Overflow)
데이터 형식의 크기를 넘어선 값을 담게 되면 넘친다는 개념으로 `오버플로우` 혹은 최저값보다 더 작은 값을 저장하려고 할 때 `언더플로우`라고 한다.

데이터를 다루는 코드를 작성할 때에는 다루려는 데이터의 범위와 변수 형식을 적절하게 맞추는 것이 중요하다.

### 부동 소수점(Floating Point Type)
소수점이 고정되어 있지 않고, 움직이면서 수를 표현한다는 뜻에서 `부동 소수점`이라고 한다.

기본적으로 `float (4byte)`, `double (8byte)`를 지원하며 더 높은 정밀도를 원한다면 `decimal (16byte)`도 지원한다.


### 박싱과 언박싱
`object`형식은 참조 형식이기 때문에 힙에 데이터를 할당한다. `int`, `double`형식은 값 형식이기 때문에 스택에 데이터를 할당한다.

`박싱(Boxing, 포장하다)`의 과정을 살펴보자.

1. 값 타입을 힙에 생성하기 위해 메모리를 힙 영역에 생성한다.
2. 값을 힙 영역에 할당된 메모리로 복사한다.
3. 참조할 변수에 할당된 메모리 주소를 할당한다.

`언박싱(Unboxing, 해제하다)`의 과정을 살펴보자.

1. 박싱값인지 확인한다.
2. 박싱된 값이라면 값 타입 변수에 복사한다.
3. 박싱한 메모리와 언박싱한 메모리 2개가 존재하게 된다. (가비지 발생)

`MSDN`에 따르면 값 형식을 참조 형식으로 박싱할 때에는 완전히 새로운 객체가 만들어져야 하며, 이러한 작업에는 할당 작업보다 최대 20배의 시간이 걸리고, 언박싱 또한 캐스팅 과정이 할당 작업보다 4배의 시간이 걸린다고 한다.

엄청난 성능 손해를 볼 수 있다. 대표적으로 `ArrayList`, `HashTable` 등이 예시다. 모두 `object`타입으로 되어 있기 때문이다.

그래서 나온 방안이 `제너릭(Generic)` 을 사용하면 박싱/언박싱을 막을 수 있다. 대표적으로 `List`, `Dictionary` 등이 예시다.

`제너릭`은 따로 데이터타입을 정하지 않고 데이터 타입 자체를 타입 파라미터로 받아 정의하게 된다. 유니티의 `GetComponent<>()`는 이러한 문제를 해결하기 위해서 제너릭을 사용할 수 있도록 구현되어 있다. 즉, 하나의 `GetComponent<>()`로 모든 타입의 컴포넌트에 대응할 수 있게 된 것이다.
































